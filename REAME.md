Что делает этот проект?
Реализованы два сервиса, которые обмениваются информацией при помощи кафки
1. Сервис монет
2. Севис пользователей
БД: mongodb
Кэширование: redis
Замеры показателей: Prometheus, Grafana

Чтобы запустить все сервисы (Linux)
Запустить в терминале: docker-compose up -d
На Windows нужно ещё предварительно запустить приложеине docker desktop

Далее, сервисы будут доступны по адресам:
- Swagger монет: http://localhost:5174/swagger

- GraphQL (HotChocolate) монет: http://localhost:5174/graphql

- Swagger пользователей: http://localhost:5180/swagger

- Prometheus: http://localhost:9090

- Grafana: http://localhost:3000 (admin/admin)

Краткое саммари по метрикам

Service Overview

1. RPS (Requests Per Second)
Назначение: 
Количество успешно обработанных запросов в секунду

Как повлиять в Swagger:
Быстрые последовательные вызовы GET /api/Coins
Параллельные запросы из нескольких вкладок

Интерпретация:
Высокий RPS + низкая Latency = оптимальная производительность
Резкий рост RPS → проверить Latency и Error Rate

2. Latency P95/P99

Назначение: 
Время обработки для 95%/99% запросов

Как повлиять в Swagger:

Вызов "тяжелых" методов: POST /api/Coins с большим JSON
Комплексные запросы с фильтрацией

Интерпретация:
P99 > 3× P95 → проблемы с "хвостом" распределения
Резкий рост Latency при увеличении RPS → узкое место

3. 4xx/5xx Error Rate

Назначение: 
Процент запросов с ошибками клиента/сервера

Как повлиять в Swagger:
Невалидные запросы: POST /api/Users с id: "string"
Запросы к несуществующим эндпоинтам

Интерпретация:
4xx > 5% → проблемы с валидацией
5xx > 0% → критические ошибки сервера
Runtime & Resources

1. CPU seconds (rate)

Назначение: 
Загрузка процессора сервисом

Как повлиять в Swagger:
Массовые операции: 
POST /api/Test/add-100-coins
Ресурсоемкие вычисления

Интерпретация:
Постоянно высокий CPU → оптимизация кода
Пики при нагрузке → норма

2. Working Set (bytes)

Назначение: 
Память, используемая процессом

Как повлиять в Swagger:
Работа с большими данными: GET /api/Coins?all=true
Создание объектов с большими полями

Интерпретация:
Постоянный рост → возможная утечка памяти
Стабильные "волны" → нормальная работа GC

3. .NET GC Heap Size (bytes)

Назначение: Размер управляемой кучи .NET

Как повлиять в Swagger:
Создание множества объектов:
многократный POST /api/Coins
Работа с большими коллекциями

Интерпретация:
Быстрый рост → много временных объектов
Высокое плато → кеширование данных

4. GC Collections/sec

Назначение: 
Частота сборок мусора

Как повлиять в Swagger:
Интенсивное создание/удаление объектов
Циклы с аллокацией памяти

Интерпретация:
Высокие значения → нагрузка на GC
Резкие всплески → пиковые нагрузки

5. Thread Pool Threads

Назначение: 
Число потоков в пуле .NET

Как повлиять в Swagger:
Параллельные запросы из нескольких вкладок
Длительные операции с async/await

Интерпретация:
Быстрый рост → блокирующие вызовы
Высокое постоянное значение → проблемы с синхронизацией

6. Process Threads

Назначение: 
Общее число потоков процесса

Как повлиять в Swagger:
Запуск фоновых операций через Kafka
Работа с внешними API

Интерпретация:
Постоянный рост → утечка потоков
Стабильные значения → норма

Примеры совместной интерпретации
Сценарий 1: Оптимальная работа

RPS: стабильный рост
Latency: плавное увеличение
CPU/Memory: пропорциональный рост
→ Система масштабируется
Сценарий 2: Проблемы с памятью

RPS: падает
Latency: растет
Working Set: постоянный рост
GC Collections/sec: высокие значения
→ Утечка памяти
Сценарий 3: Блокирующие операции

RPS: низкий
Latency: высокий
Thread Pool Threads: высокое значение
CPU: низкий
→ Проблемы синхронизации
Сценарий 4: Проблемы GC

GC Heap Size: быстрый рост
GC Collections/sec: высокие значения
CPU: высокий
→ Оптимизация аллокаций

## GraphQL API (HotChocolate)

Добавлен альтернативный API на GraphQL для сервиса монет. Эндпоинт: `http://localhost:5174/graphql`

- В Dev-режиме доступен встроенный GraphQL IDE (Banana Cake Pop) по этому же адресу.
- Поддерживаются Query и Mutation, включая фильтрацию и сортировку.

### Примеры запросов (Query)

1) Получение списка монет только с нужными полями:

```graphql
query {
  coins {
    id
    country
    price
  }
}
```

2) Фильтрация и сортировка на стороне GraphQL:

```graphql
query {
  coins(where: { country: { eq: "USA" }, price: { gte: 10 } }, order: { price: DESC }) {
    id
    country
    currency
    price
  }
}
```

3) Поиск по идентификатору:

```graphql
query($id: String!) {
  coinById(id: $id) {
    id
    country
    year
    currency
    value
    price
    confirmationTime
    confirmationInfo
  }
}
```

### Примеры мутаций (Mutation)

1) Создание монеты (при наличии `confirmedByUserId` триггерится Kafka-подтверждение):

```graphql
mutation {
  createCoin(input: {
    country: "USA"
    year: 1999
    currency: "USD"
    value: 1
    price: 25
    confirmedByUserId: "64f6e0d8c1234567890abcde"
  }) {
    id
    country
    price
    confirmationTime
  }
}
```

2) Обновление монеты:

```graphql
mutation {
  updateCoin(id: "64f6e0d8c1234567890abcde", input: {
    country: "USA"
    year: 2000
    currency: "USD"
    value: 1
    price: 30
  }) {
    id
    country
    year
    price
  }
}
```

3) Удаление монеты:

```graphql
mutation {
  deleteCoin(id: "64f6e0d8c1234567890abcde")
}
```

### Почему GraphQL удобнее на этом примере

- **Выбор полей**: клиент запрашивает только нужные поля (меньше сетевого трафика, упрощение моделей на фронте).
- **Гибкие фильтры и сортировка**: без добавления новых REST-эндпоинтов можно комбинировать условия и порядок выдачи.
- **Единая схема**: Query/Mutation в одном эндпоинте, удобная эволюция API без версионирования в URL.

### Как запустить локально

1) `dotnet restore` в решении.
2) Запустить профиль `http` для `StoreOfCoinsApi` (порт 5174). Открыть `http://localhost:5174/graphql`.
3) Для развёртывания всего стенда см. инструкцию по `docker-compose` выше.